
#
"""시간 복잡도
모든 걸 종합해보면 이렇게 나타낼 수 있습니다.

연산	시간 복잡도
접근	O(n)
탐색	O(n)
삽입	O(1)
삭제	O(1)
접근과 탐색은 O(n), 삽입과 삭제는 O(1)이죠."""

# 하지만 현실적으로
"""연산	링크드 리스트
접근	O(n)
탐색	O(n)
원하는 노드에 접근 또는 탐색 + 삽입	O(n + 1)
원하는 노드에 접근 또는 탐색 + 삭제	O(n + 1)
사실상 삽입과 삭제 연산은 접근 또는 탐색의 시간
복잡도인 O(n)를 공유한다고 볼 수 있습니다."""

"""삽입 삭제 연산 특수 경우 시간 복잡도
근데 아까 얘기했듯이, head와 tail 노드는 항상 한 번에 찾을 수 있었죠?
접근하는데 O(1)O(1), 연산을 하는데 O(1)O(1)이 걸리는데요.
그렇기 때문에 이 두 노드와 관련. 있는 삽입이나 삭제 연산들은 O(1)O(1)로
할 수 있습니다. append, prepend, pop_left 메소드를 살펴보면
head 노드와 tail 노드를 한 번에 가지고 와서 레퍼런스를 바꿔주죠?"""

"""가장 앞에 접근 + 삽입	O(1 + 1)
가장 앞에 접근 + 삭제	O(1 + 1)
가장 뒤에 접근 + 삽입	O(1 + 1)
뒤에서 두 번째 노드 (tail 노드 전 노드) 접근 + 삭제 O(n+1)
링크드 리스트 가장 뒤 노드 삭제 연산은 나머지 세 연산만큼
효율적으로 할 수 없습니다."""